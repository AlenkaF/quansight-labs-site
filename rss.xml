<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs</title><link>https://labs.quansight.org/</link><description>Quansight Labs site: blog, development and project overview</description><atom:link href="https://labs.quansight.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Wed, 18 Nov 2020 07:01:04 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Introduction to Design in Open Source</title><link>https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/</link><dc:creator>Tim George and Isabela Presedo-Floyd</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;This blog post is a conversation. Portions lead by Tim George are marked with
&lt;/em&gt;&lt;em&gt;TG&lt;/em&gt;&lt;em&gt;, and those lead by Isabela Presedo-Floyd are marked with &lt;/em&gt;&lt;em&gt;IPF&lt;/em&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TG:&lt;/strong&gt; When I speak with other designers, one common theme I see concerning why
they chose this career path is they want to make a difference in the world. We
design because we imagine a better world and we want to help make it real. Part
of the reason we design as a career is we're unable to go through life without
designing; we're always thinking about how things are and how they could be
better. This ethos also exists in many open-source communities. It seems like it
ought to be an ideal match.&lt;/p&gt;
&lt;p&gt;So what's the disconnect? I'm still exploring that myself, but after a few years
in open source I want to share my observations, experiences, and hope for a
stronger collaboration between design and development. I don't think I have a
complete solution, and some days I'm not even sure I grasp the entire problem.
What I hope is to say that which often goes unsaid in these spaces: design and
development skills in open source coexist precariously.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/"&gt;Read more…&lt;/a&gt; (10 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>design</category><category>Open-Source</category><category>User Experience</category><category>UX</category><guid>https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/</guid><pubDate>Wed, 18 Nov 2020 05:00:30 GMT</pubDate></item><item><title>Querying multiple backends with Ibis</title><link>https://labs.quansight.org/blog/2020/11/the-ibis-backends/</link><dc:creator>Tony Fast, Kim Pevey</dc:creator><description>&lt;div&gt;&lt;p&gt;In &lt;a href="https://labs.quansight.org/blog/2020/06/ibis-an-idiomatic-flavor-of-sql-for-python-programmers/"&gt;our recent Ibis post&lt;/a&gt;, we discussed querying &amp;amp; retrieving data using a familiar &lt;a href="http://pandas.pydata.org/"&gt;Pandas&lt;/a&gt;-like interface.
That discussion focused on the fluent API that &lt;a href="https://www.ibis-project.org/"&gt;Ibis&lt;/a&gt; provides to query structure from a SQLite database—in particular, using a single specific backend.
In this post, we'll explore Ibis's ability to answer questions about data using two different Ibis backends.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ibis.omniscidb&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;dask&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;intake&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;pyarrow&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;arrow&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;altair&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;h5py&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;hdf5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Ibis in the scientific Python ecosystem&lt;/h3&gt;
&lt;p&gt;Before we delve into the technical details of using Ibis, we'll consider Ibis in the greater historical context of the scientific Python ecosystem. It was started by Wes McKinney, the creator of Pandas, as way to query information on
the &lt;a href="https://en.wikipedia.org/wiki/Apache_Hadoop#HDFS"&gt;Hadoop distributed file system&lt;/a&gt; and &lt;a href="https://pypi.org/project/pyspark/"&gt;PySpark&lt;/a&gt;. More backends were added later as Ibis became a general tool for data queries.&lt;/p&gt;
&lt;p&gt;Throughout the rest of this post, we'll highlight the ability of Ibis to generically prescribe
query expressions across different data storage systems.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/the-ibis-backends/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Ibis</category><category>OmniSci</category><category>Pandas</category><category>SQL</category><guid>https://labs.quansight.org/blog/2020/11/the-ibis-backends/</guid><pubDate>Fri, 13 Nov 2020 06:00:00 GMT</pubDate></item><item><title>Manylinux1 is obsolete, manylinux2010 is almost EOL, what is next?</title><link>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</link><dc:creator>Matti Picus</dc:creator><description>&lt;div&gt;&lt;p&gt;The basic installation format for users who install packages via &lt;code&gt;pip&lt;/code&gt; is
the wheel format. Wheel names are composed of four parts: a
package-name-and-version tag (which can be further broken down), a Python tag,
an ABI tag, and a platform tag. More information on the tags can be found in
&lt;a href="https://www.python.org/dev/peps/pep-0425"&gt;PEP 425&lt;/a&gt;.  So a package like NumPy
will be available on PyPI as &lt;code&gt;numpy-1.19.2-cp36-cp36m-win_amd64.whl&lt;/code&gt; for 64-bit
windows and &lt;code&gt;numpy-1.19.2-cp36-cp36m-macosx_10_9_x86_64.whl&lt;/code&gt; for macOS. Note
that only the plaform tag &lt;code&gt;win_amd64&lt;/code&gt; or &lt;code&gt;macosx_10_9_x86_64&lt;/code&gt; differs. &lt;/p&gt;
&lt;p&gt;But what about Linux? There is no single, vendor controlled, "Linux platform"
e.g., Ubuntu, RedHat, Fedora, Debian, FreeBSD all package software at slightly
different versions. What most Linux distributions do have in common is the
glibc runtime library, and a smattering of various additional system libraries.
So it is possible to define a least common denominator (LCD) of software
expected to be on a Linux platform (exceptions apply, e.g. non-glibc
distributions).&lt;/p&gt;
&lt;p&gt;The decision to converge on a LCD common platform gave birth to the
&lt;a href="https://www.python.org/dev/peps/pep-0513/"&gt;manylinux1&lt;/a&gt; standard. Going back
to our example, numpy is available as
&lt;code&gt;numpy-1.19.2-cp36-cp36m-manylinux1_x86_64.whl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first manylinux standard, manylinux1, was based on CentOS5 which has &lt;a href="https://endoflife.software/operating-systems/linux/centos"&gt;been
obsolete&lt;/a&gt; since
March 2017. The subsequent manylinux2010 standard is based on CentOS6, which
will hit end-of-life in December 2020. The manylinux2014 standard still has some
breathing room. Based on CentOS7, it will reach end-of-life in July 2024.&lt;/p&gt;
&lt;p&gt;So what is next for &lt;code&gt;manylinux&lt;/code&gt;, and what &lt;code&gt;manylinux&lt;/code&gt; should users and package
maintainers use?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>manylinux</category><category>packaging</category><category>pip</category><guid>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</guid><pubDate>Thu, 12 Nov 2020 19:00:06 GMT</pubDate></item><item><title>Design of the Versioned HDF5 Library</title><link>https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;In a &lt;a href="https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/"&gt;previous
post&lt;/a&gt;, we
introduced the Versioned HDF5 library and described some of its features. In
this post, we'll go into detail on how the underlying design of the library
works on a technical level.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>h5py</category><category>HDF5</category><guid>https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/</guid><pubDate>Tue, 29 Sep 2020 16:00:00 GMT</pubDate></item><item><title>Performance of the Versioned HDF5 Library</title><link>https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/</link><dc:creator>Melissa Weber Mendonça</dc:creator><description>&lt;div&gt;&lt;p&gt;In several industry and science applications, a filesystem-like storage model such as &lt;a href="https://www.hdfgroup.org/solutions/hdf5/"&gt;HDF5&lt;/a&gt; is the more appropriate solution for manipulating large amounts of data. However, suppose that data changes over time. In that case, it's not obvious how to track those different versions, since HDF5 is a binary format and is not well suited for traditional version control systems and tools. &lt;/p&gt;
&lt;p&gt;In a &lt;a href="https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/"&gt;previous post&lt;/a&gt;, we introduced the Versioned HDF5 library, which implements a mechanism for storing binary data sets in a versioned way that feels natural to users of other version control systems, and described some of its features. In this post, we'll show some of the performance analysis we did while developing the library, hopefully making the case that reading and writing versioned HDF5 files can be done with a nice, intuitive API while being as efficient as possible. The tests presented here show that using the Versioned HDF5 library results in reduced disk space usage, and further reductions in this area can be achieved with the use of HDF5/&lt;a href="https://www.h5py.org"&gt;h5py&lt;/a&gt;-provided compression algorithms. That only comes at a cost of &amp;lt;10x file writing speed.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>h5py</category><category>HDF5</category><guid>https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/</guid><pubDate>Fri, 11 Sep 2020 11:00:00 GMT</pubDate></item><item><title>PyTorch-Ignite: training and evaluating neural networks flexibly and transparently</title><link>https://labs.quansight.org/blog/2020/09/pytorch-ignite/</link><dc:creator>Victor Fomin</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;!--# PyTorch-Ignite: training and evaluating neural networks flexibly and transparently--&gt;

&lt;!--div align="center"&gt;
&lt;img width=512 src="https://i.ibb.co/WtbmXJQ/ignite-blog.jpg"/&gt;
&lt;/div--&gt;

&lt;div align="center"&gt;
&lt;img width="512" src="https://i.ibb.co/x8Bhqhj/habr-pytorch-ignite-image.png"&gt;
&lt;/div&gt;&lt;div align="center"&gt;
Authors: Victor Fomin (Quansight), Sylvain Desroziers (IFPEN, France)
&lt;/div&gt;&lt;div&gt;
This post is a general introduction of PyTorch-Ignite. It intends to give a brief but illustrative overview of what PyTorch-Ignite can offer for Deep Learning enthusiasts, professionals and researchers. Following the same philosophy as PyTorch, PyTorch-Ignite aims to keep it simple, flexible and extensible but performant and scalable.
&lt;/div&gt;&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/pytorch-ignite/"&gt;Read more…&lt;/a&gt; (28 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Deep Learning</category><category>Labs</category><category>Machine Learning</category><category>Neural Networks</category><category>Python</category><category>PyTorch</category><category>Tutorial</category><guid>https://labs.quansight.org/blog/2020/09/pytorch-ignite/</guid><pubDate>Thu, 10 Sep 2020 05:00:00 GMT</pubDate></item><item><title>Traitlets - an introduction &amp; use in Jupyter configuration management</title><link>https://labs.quansight.org/blog/2020/08/what-are-traitlets/</link><dc:creator>Matthias Bussonnier, Tony Fast</dc:creator><description>&lt;div&gt;&lt;p&gt;You have probably seen Traitlets in applications, you likely even use it. The package has nearly 5 million downloads
on &lt;a href="https://anaconda.org/conda-forge/traitlets"&gt;conda-forge&lt;/a&gt; alone.&lt;/p&gt;
&lt;h2&gt;But, what is Traitlets ?&lt;/h2&gt;
&lt;p&gt;In this post we'll answer this question along with where Traitlets came from, its applications, and a bit of history.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/what-are-traitlets/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>community</category><category>historical</category><category>IPython</category><category>Jupyter</category><category>Labs</category><category>Python</category><category>traitlets</category><guid>https://labs.quansight.org/blog/2020/08/what-are-traitlets/</guid><pubDate>Sun, 30 Aug 2020 09:00:00 GMT</pubDate></item><item><title>IPython reproducible builds</title><link>https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/</link><dc:creator>Matthias Bussonnier</dc:creator><description>&lt;div&gt;&lt;p&gt;Starting with IPython 7.16.1 (released in June 2020), you &lt;em&gt;should&lt;/em&gt; be able to recreate the sdist (&lt;code&gt;.tar.gz&lt;/code&gt;) and wheel
(&lt;code&gt;.whl&lt;/code&gt;), and get byte for byte identical result to the wheels published on PyPI. This is a critical step toward being able
to &lt;em&gt;trust&lt;/em&gt; your computing platforms, and a key component to improve efficiency of build and packaging platforms. It also
potentially impacts fast conda environment creation for users. The following goes into some reasons for why you should care.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IPython</category><category>Labs</category><category>packaging</category><category>reproducible-builds</category><guid>https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/</guid><pubDate>Mon, 24 Aug 2020 12:00:00 GMT</pubDate></item><item><title>Introducing Versioned HDF5</title><link>https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/</link><dc:creator>Melissa Weber Mendonça</dc:creator><description>&lt;div&gt;&lt;p&gt;The problem of storing and manipulating large amounts of data is a challenge in
many scientific computing and industry applications. One of the standard data
models for this is &lt;a href="https://support.hdfgroup.org/HDF5/whatishdf5.html"&gt;HDF5&lt;/a&gt;,
an open technology that implements a hierarchical structure (similar to a
file-system structure) for storing large amounts of possibly heterogeneous data
within a single file. Data in an HDF5 file is organized into &lt;em&gt;groups&lt;/em&gt; and
&lt;em&gt;datasets&lt;/em&gt;; you can think about these as the folders and files in your local
file system, respectively. You can also optionally store metadata associated
with each item in a file, which makes this a self-describing and powerful data
storage model.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>h5py</category><category>HDF5</category><guid>https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/</guid><pubDate>Fri, 21 Aug 2020 13:00:00 GMT</pubDate></item><item><title>Designing with and for developers</title><link>https://labs.quansight.org/blog/2020/08/designing-with-and-for-developers/</link><dc:creator>Isabela Presedo-Floyd</dc:creator><description>&lt;div&gt;&lt;p&gt;Open source is notorious for lack of design presence, enough so that my search
to prove this fact has turned up nearly nothing. There’s many ways that such a
gap in community might manifest, but one that I never anticipated was working
with developers that had never interacted with a designer before.&lt;/p&gt;
&lt;p&gt;A quick note for context: I’m writing this as a UX/UI designer working with
open source projects for a little over a year. Because there are so many ways
design processes can happen (enough to warrant its own blog post), this post is
not intended to discuss design process deeply. My goal here is to pass on some
of what I’ve learned that helps me design in this unusual space in hopes that
it can help someone else. This post might seem most relevant for designers, but
I think this experience could be helpful for developers as well.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/designing-with-and-for-developers/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>design</category><guid>https://labs.quansight.org/blog/2020/08/designing-with-and-for-developers/</guid><pubDate>Wed, 05 Aug 2020 20:55:42 GMT</pubDate></item></channel></rss>