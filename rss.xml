<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs</title><link>https://labs.quansight.org/</link><description>Quansight Labs site: blog, development and project overview</description><atom:link href="https://labs.quansight.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Fri, 05 Feb 2021 10:55:06 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Python packaging in 2021 - pain points and bright spots</title><link>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</link><dc:creator>Ralf Gommers</dc:creator><description>&lt;div&gt;&lt;p&gt;At Quansight we have a weekly "Q-share" session on Fridays where everyone can
share/demo things they have worked on, recently learned, or that simply seem
interesting to share with their colleagues. This can be about anything, from
new utilities to low-level performance, from building inclusive communities
to how to write better documentation, from UX design to what legal &amp;amp;
accounting does to support the business. This week I decided to try something
different: hold a brainstorm on the state of Python packaging today.&lt;/p&gt;
&lt;p&gt;The ~30 participants were mostly from the PyData world, but not exclusively -
it included people with backgrounds and preferences ranging from C, C++ and
Fortran to JavaScript, R and DevOps - and with experience as end-users,
packagers, library authors, and educators. This blog post contains the raw
output of the 30-minute brainstorm (only cleaned up for textual issues) and
my annotations on it (in italics) which capture some of the discussion during
the session and links and context that may be helpful. I think it sketches a
decent picture of the main pain points of Python packaging for users and
developers interacting with the Python data and numerical computing ecosystem.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Conda</category><category>conda-forge</category><category>CUDA</category><category>manylinux</category><category>packaging</category><category>pip</category><category>PyData</category><category>PyPI</category><category>Python</category><category>setuptools</category><guid>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</guid><pubDate>Sun, 24 Jan 2021 04:00:00 GMT</pubDate></item><item><title>Making SciPy's Image Interpolation Consistent and Well Documented</title><link>https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/</link><dc:creator>Gregory Lee</dc:creator><description>&lt;div&gt;&lt;h2&gt;SciPy n-dimensional Image Processing&lt;/h2&gt;
&lt;p&gt;SciPy's ndimage module provides a powerful set of general, n-dimensional image processing operations, categorized into areas such as filtering, interpolation and morphology. Traditional image processing deals with 2D arrays of pixels, possibly with an additional array dimension of size 3 or 4 to represent color channel and transparency information. However, there are many scientific applications where we may want to work with more general arrays such as the 3D volumetric images produced by medical imaging methods like computed tomography (CT) or magnetic resonance imaging (MRI) or biological imaging approaches such as light sheet microscopy. Aside from spatial axes, such data may have additional axes representing other quantities such as time, color, spectral frequency or different contrasts. Functions in ndimage have been implemented in a general n-dimensional manner so that they can be applied across 2D, 3D or more dimensions. A more detailed overview of the module is available in the
&lt;a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html"&gt;SciPy ndimage tutorial&lt;/a&gt;. SciPy's image functions are also used by downstream libraries such as &lt;a href="https://scikit-image.org"&gt;scikit-image&lt;/a&gt; to implement higher-level algorithms for things like image restoration, segmentation and registration.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Labs</category><category>Open-Source</category><category>Python</category><category>SciPy</category><guid>https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/</guid><pubDate>Fri, 22 Jan 2021 14:00:00 GMT</pubDate></item><item><title>Welcoming Tania Allard as Quansight Labs co-director</title><link>https://labs.quansight.org/blog/2021/01/welcoming-tania-allard-labs-codirector/</link><dc:creator>Ralf Gommers</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="Photo Tania Allard" src="https://labs.quansight.org/galleries/team/tania_allard.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Today I'm incredibly excited to welcome Tania Allard to Quansight as
Co-Director of Quansight Labs. Tania (&lt;a href="https://github.com/trallard"&gt;GitHub&lt;/a&gt;,
&lt;a href="https://twitter.com/ixek/"&gt;Twitter&lt;/a&gt;, &lt;a href="https://www.bitsandchips.me/"&gt;personal
site&lt;/a&gt;) is a well-known and prolific PyData
community member. In the past few years she has been involved as a conference
organizer (JupyterCon, SciPy, PyJamas, PyCon UK, PyCon LatAm, JuliaCon and
more), as a community builder (PyLadies, NumFOCUS, RForwards), as a
contributor to Matplotlib and Jupyter, and as a regular speaker and mentor.
She also brings relevant experience in both industry and academia - she joins
us from Microsoft where she was a senior developer advocate, and has a PhD in
computational modelling.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/welcoming-tania-allard-labs-codirector/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Labs</category><guid>https://labs.quansight.org/blog/2021/01/welcoming-tania-allard-labs-codirector/</guid><pubDate>Mon, 04 Jan 2021 08:00:00 GMT</pubDate></item><item><title>Develop a JupyterLab Winter Theme</title><link>https://labs.quansight.org/blog/2020/12/jupyterlab-winter-theme/</link><dc:creator>Matthias Bussonnier, Isabela Presedo Floyd, Eric Charles, Eric Kelly, Tony Fast</dc:creator><description>&lt;div&gt;&lt;p&gt;JupyterLab 3.0 is about to be released and provides many 
improvements to the extension system. Theming is a way to extend JupyterLab and 
benefits from those improvements.&lt;/p&gt;
&lt;p&gt;While theming is often disregarded as a purely cosmetic endeavour, it can greatly
improve software. Theming can be great help for accessibility, and the Jupyter team
pays attention to making the default appearance accessibility-aware by using
sufficient contrast.  For users with a high visual acuity you may also choose 
to increase the information density.&lt;/p&gt;
&lt;p&gt;Theming can also be a great way to improve communication by increasing or
decreasing emphasis of the user interface, which can be of use for teaching or
presenting. Theming may also help with security, for example, by having a clear
distinction between staging and production.&lt;/p&gt;
&lt;p&gt;Finally Theming can be a great way to express oneself, for example, by using
a branded version of software that fits well into a context, or expressing one's artistic
preferences or opinions. &lt;/p&gt;
&lt;p&gt;In the following blog post, we will show you step-by-step how you can
develop a custom theme for JupyterLab, distribute it, and take the example of the
&lt;a href="https://github.com/Quansight-Labs/jupyterlab-theme-winter"&gt;jupyterlab-theme-winter&lt;/a&gt; theme we release today to celebrate the end of 2020.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/12/jupyterlab-winter-theme/"&gt;Read more…&lt;/a&gt; (9 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Jupyter</category><category>JupyterLab</category><category>JupyterTutorials</category><category>Labs</category><category>Theme</category><guid>https://labs.quansight.org/blog/2020/12/jupyterlab-winter-theme/</guid><pubDate>Tue, 22 Dec 2020 09:00:00 GMT</pubDate></item><item><title>A second CZI grant for NumPy and OpenBLAS</title><link>https://labs.quansight.org/blog/2020/11/a-second-czi-grant-for-numpy-and-openblas/</link><dc:creator>Melissa Weber Mendonça</dc:creator><description>&lt;div&gt;&lt;p&gt;I am happy to announce that NumPy and OpenBLAS have once again been awarded a
grant from the Chan Zuckerberg Initiative through
&lt;a href="https://chanzuckerberg.com/newsroom/czi-awards-4-7-million-for-open-source-software-and-organizations-advancing-open-science/"&gt;Cycle 3 of the Essential Open Source Software for Science (EOSS) program&lt;/a&gt;.
This new grant totaling $140,000 will fund part of our efforts to improve
usability and sustainability in both projects and is excellent news for the
scientific computing community, which will certainly benefit from this work
downstream.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/a-second-czi-grant-for-numpy-and-openblas/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>CZI</category><category>funding</category><category>grant</category><category>NumPy</category><category>OpenBLAS</category><guid>https://labs.quansight.org/blog/2020/11/a-second-czi-grant-for-numpy-and-openblas/</guid><pubDate>Thu, 19 Nov 2020 17:29:55 GMT</pubDate></item><item><title>Introduction to Design in Open Source</title><link>https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/</link><dc:creator>Tim George and Isabela Presedo-Floyd</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;This blog post is a conversation. Portions lead by Tim George are marked with
&lt;/em&gt;&lt;em&gt;TG&lt;/em&gt;&lt;em&gt;, and those lead by Isabela Presedo-Floyd are marked with &lt;/em&gt;&lt;em&gt;IPF&lt;/em&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TG:&lt;/strong&gt; When I speak with other designers, one common theme I see concerning why
they chose this career path is they want to make a difference in the world. We
design because we imagine a better world and we want to help make it real. Part
of the reason we design as a career is we're unable to go through life without
designing; we're always thinking about how things are and how they could be
better. This ethos also exists in many open-source communities. It seems like it
ought to be an ideal match.&lt;/p&gt;
&lt;p&gt;So what's the disconnect? I'm still exploring that myself, but after a few years
in open source I want to share my observations, experiences, and hope for a
stronger collaboration between design and development. I don't think I have a
complete solution, and some days I'm not even sure I grasp the entire problem.
What I hope is to say that which often goes unsaid in these spaces: design and
development skills in open source coexist precariously.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/"&gt;Read more…&lt;/a&gt; (10 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>design</category><category>Open-Source</category><category>User Experience</category><category>UX</category><guid>https://labs.quansight.org/blog/2020/11/introduction-to-design-in-open-source/</guid><pubDate>Wed, 18 Nov 2020 05:00:30 GMT</pubDate></item><item><title>Querying multiple backends with Ibis</title><link>https://labs.quansight.org/blog/2020/11/the-ibis-backends/</link><dc:creator>Tony Fast, Kim Pevey</dc:creator><description>&lt;div&gt;&lt;p&gt;In &lt;a href="https://labs.quansight.org/blog/2020/06/ibis-an-idiomatic-flavor-of-sql-for-python-programmers/"&gt;our recent Ibis post&lt;/a&gt;, we discussed querying &amp;amp; retrieving data using a familiar &lt;a href="http://pandas.pydata.org/"&gt;Pandas&lt;/a&gt;-like interface.
That discussion focused on the fluent API that &lt;a href="https://www.ibis-project.org/"&gt;Ibis&lt;/a&gt; provides to query structure from a SQLite database—in particular, using a single specific backend.
In this post, we'll explore Ibis's ability to answer questions about data using two different Ibis backends.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ibis.omniscidb&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;dask&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;intake&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;pyarrow&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;arrow&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;altair&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;h5py&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;hdf5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;Ibis in the scientific Python ecosystem&lt;/h3&gt;
&lt;p&gt;Before we delve into the technical details of using Ibis, we'll consider Ibis in the greater historical context of the scientific Python ecosystem. It was started by Wes McKinney, the creator of Pandas, as way to query information on
the &lt;a href="https://en.wikipedia.org/wiki/Apache_Hadoop#HDFS"&gt;Hadoop distributed file system&lt;/a&gt; and &lt;a href="https://pypi.org/project/pyspark/"&gt;PySpark&lt;/a&gt;. More backends were added later as Ibis became a general tool for data queries.&lt;/p&gt;
&lt;p&gt;Throughout the rest of this post, we'll highlight the ability of Ibis to generically prescribe
query expressions across different data storage systems.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/the-ibis-backends/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Ibis</category><category>OmniSci</category><category>Pandas</category><category>SQL</category><guid>https://labs.quansight.org/blog/2020/11/the-ibis-backends/</guid><pubDate>Fri, 13 Nov 2020 06:00:00 GMT</pubDate></item><item><title>Manylinux1 is obsolete, manylinux2010 is almost EOL, what is next?</title><link>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</link><dc:creator>Matti Picus</dc:creator><description>&lt;div&gt;&lt;p&gt;The basic installation format for users who install packages via &lt;code&gt;pip&lt;/code&gt; is
the wheel format. Wheel names are composed of four parts: a
package-name-and-version tag (which can be further broken down), a Python tag,
an ABI tag, and a platform tag. More information on the tags can be found in
&lt;a href="https://www.python.org/dev/peps/pep-0425"&gt;PEP 425&lt;/a&gt;.  So a package like NumPy
will be available on PyPI as &lt;code&gt;numpy-1.19.2-cp36-cp36m-win_amd64.whl&lt;/code&gt; for 64-bit
windows and &lt;code&gt;numpy-1.19.2-cp36-cp36m-macosx_10_9_x86_64.whl&lt;/code&gt; for macOS. Note
that only the plaform tag &lt;code&gt;win_amd64&lt;/code&gt; or &lt;code&gt;macosx_10_9_x86_64&lt;/code&gt; differs. &lt;/p&gt;
&lt;p&gt;But what about Linux? There is no single, vendor controlled, "Linux platform"
e.g., Ubuntu, RedHat, Fedora, Debian, FreeBSD all package software at slightly
different versions. What most Linux distributions do have in common is the
glibc runtime library, and a smattering of various additional system libraries.
So it is possible to define a least common denominator (LCD) of software
expected to be on a Linux platform (exceptions apply, e.g. non-glibc
distributions).&lt;/p&gt;
&lt;p&gt;The decision to converge on a LCD common platform gave birth to the
&lt;a href="https://www.python.org/dev/peps/pep-0513/"&gt;manylinux1&lt;/a&gt; standard. Going back
to our example, numpy is available as
&lt;code&gt;numpy-1.19.2-cp36-cp36m-manylinux1_x86_64.whl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first manylinux standard, manylinux1, was based on CentOS5 which has &lt;a href="https://endoflife.software/operating-systems/linux/centos"&gt;been
obsolete&lt;/a&gt; since
March 2017. The subsequent manylinux2010 standard is based on CentOS6, which
will hit end-of-life in December 2020. The manylinux2014 standard still has some
breathing room. Based on CentOS7, it will reach end-of-life in July 2024.&lt;/p&gt;
&lt;p&gt;So what is next for &lt;code&gt;manylinux&lt;/code&gt;, and what &lt;code&gt;manylinux&lt;/code&gt; should users and package
maintainers use?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>manylinux</category><category>packaging</category><category>pip</category><guid>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</guid><pubDate>Thu, 12 Nov 2020 19:00:06 GMT</pubDate></item><item><title>Design of the Versioned HDF5 Library</title><link>https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;In a &lt;a href="https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/"&gt;previous
post&lt;/a&gt;, we
introduced the Versioned HDF5 library and described some of its features. In
this post, we'll go into detail on how the underlying design of the library
works on a technical level.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>h5py</category><category>HDF5</category><guid>https://labs.quansight.org/blog/2020/09/design-of-the-versioned-hdf5-library/</guid><pubDate>Tue, 29 Sep 2020 16:00:00 GMT</pubDate></item><item><title>Performance of the Versioned HDF5 Library</title><link>https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/</link><dc:creator>Melissa Weber Mendonça</dc:creator><description>&lt;div&gt;&lt;p&gt;In several industry and science applications, a filesystem-like storage model such as &lt;a href="https://www.hdfgroup.org/solutions/hdf5/"&gt;HDF5&lt;/a&gt; is the more appropriate solution for manipulating large amounts of data. However, suppose that data changes over time. In that case, it's not obvious how to track those different versions, since HDF5 is a binary format and is not well suited for traditional version control systems and tools. &lt;/p&gt;
&lt;p&gt;In a &lt;a href="https://labs.quansight.org/blog/2020/08/introducing-versioned-hdf5/"&gt;previous post&lt;/a&gt;, we introduced the Versioned HDF5 library, which implements a mechanism for storing binary data sets in a versioned way that feels natural to users of other version control systems, and described some of its features. In this post, we'll show some of the performance analysis we did while developing the library, hopefully making the case that reading and writing versioned HDF5 files can be done with a nice, intuitive API while being as efficient as possible. The tests presented here show that using the Versioned HDF5 library results in reduced disk space usage, and further reductions in this area can be achieved with the use of HDF5/&lt;a href="https://www.h5py.org"&gt;h5py&lt;/a&gt;-provided compression algorithms. That only comes at a cost of &amp;lt;10x file writing speed.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>h5py</category><category>HDF5</category><guid>https://labs.quansight.org/blog/2020/09/versioned-hdf5-performance/</guid><pubDate>Fri, 11 Sep 2020 11:00:00 GMT</pubDate></item></channel></rss>