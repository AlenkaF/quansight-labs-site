<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs (Posts about packaging)</title><link>https://labs.quansight.org/</link><description></description><atom:link href="https://labs.quansight.org/categories/packaging.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Thu, 02 Sep 2021 10:52:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Moving SciPy to the Meson build system</title><link>https://labs.quansight.org/blog/2021/07/moving-scipy-to-meson/</link><dc:creator>Ralf Gommers</dc:creator><description>&lt;div&gt;&lt;p&gt;Let's start with an announcement: &lt;em&gt;&lt;strong&gt;SciPy now builds with
&lt;a href="https://mesonbuild.com/"&gt;Meson&lt;/a&gt; on Linux, and the full test suite passes!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a pretty exciting milestone, and good news for SciPy maintainers and
contributors - they can look forward to much faster builds and a more
pleasant development experience. So how fast is it? Currently the build takes
about 1min 50s (a ~4x improvement) on my 3 year old 12-core Intel CPU
(i9-7920X @ 2.90GHz):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Profiling result of a parallel build of SciPy with Meson" src="https://labs.quansight.org/images/2021/07/ninjabuild_tracing_12jobs.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Profiling result of a parallel build (12 jobs) of SciPy with Meson. Visualization created with &lt;a href="https://github.com/nico/ninjatracing/blob/master/ninjatracing"&gt;ninjatracing&lt;/a&gt; and &lt;a href="https://ui.perfetto.dev"&gt;Perfetto&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As you can see from the tracing results, building a single C++ file
(&lt;code&gt;bsr.cxx&lt;/code&gt;, which is one of SciPy's sparse matrix formats) takes over 90
seconds. So the 1min 50 sec build time is close to optimal - the only ways to improve it are major surgery on that C++ code, or buying a faster CPU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/07/moving-scipy-to-meson/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>build</category><category>Labs</category><category>Meson</category><category>packaging</category><category>SciPy</category><guid>https://labs.quansight.org/blog/2021/07/moving-scipy-to-meson/</guid><pubDate>Sun, 25 Jul 2021 18:00:00 GMT</pubDate></item><item><title>Python packaging in 2021 - pain points and bright spots</title><link>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</link><dc:creator>Ralf Gommers</dc:creator><description>&lt;div&gt;&lt;p&gt;At Quansight we have a weekly "Q-share" session on Fridays where everyone can
share/demo things they have worked on, recently learned, or that simply seem
interesting to share with their colleagues. This can be about anything, from
new utilities to low-level performance, from building inclusive communities
to how to write better documentation, from UX design to what legal &amp;amp;
accounting does to support the business. This week I decided to try something
different: hold a brainstorm on the state of Python packaging today.&lt;/p&gt;
&lt;p&gt;The ~30 participants were mostly from the PyData world, but not exclusively -
it included people with backgrounds and preferences ranging from C, C++ and
Fortran to JavaScript, R and DevOps - and with experience as end-users,
packagers, library authors, and educators. This blog post contains the raw
output of the 30-minute brainstorm (only cleaned up for textual issues) and
my annotations on it (in italics) which capture some of the discussion during
the session and links and context that may be helpful. I think it sketches a
decent picture of the main pain points of Python packaging for users and
developers interacting with the Python data and numerical computing ecosystem.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Conda</category><category>conda-forge</category><category>CUDA</category><category>manylinux</category><category>packaging</category><category>pip</category><category>PyData</category><category>PyPI</category><category>Python</category><category>setuptools</category><guid>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</guid><pubDate>Sun, 24 Jan 2021 04:00:00 GMT</pubDate></item><item><title>Manylinux1 is obsolete, manylinux2010 is almost EOL, what is next?</title><link>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</link><dc:creator>Matti Picus</dc:creator><description>&lt;div&gt;&lt;p&gt;The basic installation format for users who install packages via &lt;code&gt;pip&lt;/code&gt; is
the wheel format. Wheel names are composed of four parts: a
package-name-and-version tag (which can be further broken down), a Python tag,
an ABI tag, and a platform tag. More information on the tags can be found in
&lt;a href="https://www.python.org/dev/peps/pep-0425"&gt;PEP 425&lt;/a&gt;.  So a package like NumPy
will be available on PyPI as &lt;code&gt;numpy-1.19.2-cp36-cp36m-win_amd64.whl&lt;/code&gt; for 64-bit
windows and &lt;code&gt;numpy-1.19.2-cp36-cp36m-macosx_10_9_x86_64.whl&lt;/code&gt; for macOS. Note
that only the plaform tag &lt;code&gt;win_amd64&lt;/code&gt; or &lt;code&gt;macosx_10_9_x86_64&lt;/code&gt; differs. &lt;/p&gt;
&lt;p&gt;But what about Linux? There is no single, vendor controlled, "Linux platform"
e.g., Ubuntu, RedHat, Fedora, Debian, FreeBSD all package software at slightly
different versions. What most Linux distributions do have in common is the
glibc runtime library, and a smattering of various additional system libraries.
So it is possible to define a least common denominator (LCD) of software
expected to be on a Linux platform (exceptions apply, e.g. non-glibc
distributions).&lt;/p&gt;
&lt;p&gt;The decision to converge on a LCD common platform gave birth to the
&lt;a href="https://www.python.org/dev/peps/pep-0513/"&gt;manylinux1&lt;/a&gt; standard. Going back
to our example, numpy is available as
&lt;code&gt;numpy-1.19.2-cp36-cp36m-manylinux1_x86_64.whl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first manylinux standard, manylinux1, was based on CentOS5 which has &lt;a href="https://endoflife.software/operating-systems/linux/centos"&gt;been
obsolete&lt;/a&gt; since
March 2017. The subsequent manylinux2010 standard is based on CentOS6, which
will hit end-of-life in December 2020. The manylinux2014 standard still has some
breathing room. Based on CentOS7, it will reach end-of-life in July 2024.&lt;/p&gt;
&lt;p&gt;So what is next for &lt;code&gt;manylinux&lt;/code&gt;, and what &lt;code&gt;manylinux&lt;/code&gt; should users and package
maintainers use?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>manylinux</category><category>packaging</category><category>pip</category><guid>https://labs.quansight.org/blog/2020/11/manylinux1-is-obsolete-manylinux2010-is-almost-eol-what-is-next/</guid><pubDate>Thu, 12 Nov 2020 19:00:06 GMT</pubDate></item><item><title>IPython reproducible builds</title><link>https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/</link><dc:creator>Matthias Bussonnier</dc:creator><description>&lt;div&gt;&lt;p&gt;Starting with IPython 7.16.1 (released in June 2020), you &lt;em&gt;should&lt;/em&gt; be able to recreate the sdist (&lt;code&gt;.tar.gz&lt;/code&gt;) and wheel
(&lt;code&gt;.whl&lt;/code&gt;), and get byte for byte identical result to the wheels published on PyPI. This is a critical step toward being able
to &lt;em&gt;trust&lt;/em&gt; your computing platforms, and a key component to improve efficiency of build and packaging platforms. It also
potentially impacts fast conda environment creation for users. The following goes into some reasons for why you should care.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IPython</category><category>Labs</category><category>packaging</category><category>reproducible-builds</category><guid>https://labs.quansight.org/blog/2020/08/ipython-reproducible-builds/</guid><pubDate>Mon, 24 Aug 2020 12:00:00 GMT</pubDate></item></channel></rss>