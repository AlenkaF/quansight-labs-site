<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs (Posts by Saul Shanabrook)</title><link>https://labs.quansight.org/</link><description></description><atom:link href="https://labs.quansight.org/authors/saul-shanabrook.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Fri, 31 May 2019 13:59:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>metadsl: A Framework for Domain Specific Languages in Python</title><link>https://labs.quansight.org/blog/2019/05/metadsl-dsl-framework/</link><dc:creator>Saul Shanabrook</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="metadsl:-A-Framework-for-Domain-Specific-Languages-in-Python"&gt;&lt;a href="https://github.com/quansight-labs/metadsl"&gt;&lt;code&gt;metadsl&lt;/code&gt;&lt;/a&gt;: A Framework for Domain Specific Languages in Python&lt;a class="anchor-link" href="https://labs.quansight.org/blog/2019/05/metadsl-dsl-framework/#metadsl:-A-Framework-for-Domain-Specific-Languages-in-Python"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Hello, my name is Saul Shanabrook and for the past year or so I have been at Quansight exploring the array computing ecosystem. This started with working on the &lt;a href="https://xnd.io/"&gt;xnd project&lt;/a&gt;, a set of low level primitives to help build cross platform NumPy-like APIs, and then &lt;a href="https://github.com/saulshanabrook/moa"&gt;started&lt;/a&gt; &lt;a href="https://github.com/saulshanabrook/moa"&gt;exploring&lt;/a&gt; Lenore Mullin's work on a mathematics of arrays. After spending quite a bit of time working on an integrated solution built on these concepts, I decided to step back to try to generalize and simplify the core concepts. The trickiest part was not actually compiling mathematical descriptions of array operations in Python, but figuring out how to make it useful to existing users. To do this, we need to meet users where they are at, which is with the APIs they are already familiar with, like &lt;code&gt;numpy&lt;/code&gt;. The goal of &lt;code&gt;metadsl&lt;/code&gt; is to make it easier to tackle parts of this problem seperately so that we can collaborate on tackling it together.&lt;/p&gt;
&lt;h3 id="Libraries-for-Scientific-Computing"&gt;Libraries for Scientific Computing&lt;a class="anchor-link" href="https://labs.quansight.org/blog/2019/05/metadsl-dsl-framework/#Libraries-for-Scientific-Computing"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Much of the recent rise of Python's popularity is due to its usage for scientific computing and machine learning. This work is built on different frameworks, like Pandas, NumPy, Tensorflow, and scikit-learn. Each of these are meant to be used from Python, but have their own concepts and abstractions to learn on top of the core language, so we can look at them as Domain Specific Languages (DSLs). As the ecosystem has matured, we are now demanding more flexibility for how these languages are executed. Dask gives us a way to write Pandas or NumPy and execute it across many cores or computers, Ibis allows us to write Pandas but on a SQL database, with CuPy we can execute NumPy on our GPU, and with Numba we can optimize our NumPy expession on a CPU or GPU. These projects prove that it is possible to write optimizing compilers that target varying hardware paradigms for existing Python numeric APIs. However, this isn't straightforward and these projects success is a testament to the perserverence and ingenuity of the authors. We need to make it easy to add reusable optimizations to libraries like these, so that we can support the latest hardware and compiler optimizations from Python. &lt;a href="https://github.com/quansight-labs/metadsl"&gt;&lt;code&gt;metadsl&lt;/code&gt;&lt;/a&gt; is meant to be a place to come together to build a framework for DSLs in Python. It provides a way to seperate the user experience from the the specific of execution, to enable consistency and flexibility for users. In this post, I will go through an example of creating a very basic DSL. It will not use the &lt;code&gt;metadsl&lt;/code&gt; library, but will created in the same style as &lt;code&gt;metadsl&lt;/code&gt; to illustrate its basic principles.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2019/05/metadsl-dsl-framework/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><guid>https://labs.quansight.org/blog/2019/05/metadsl-dsl-framework/</guid><pubDate>Fri, 31 May 2019 05:00:00 GMT</pubDate></item></channel></rss>