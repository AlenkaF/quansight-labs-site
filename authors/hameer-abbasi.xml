<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs (Posts by Hameer Abbasi)</title><link>https://labs.quansight.org/</link><description></description><atom:link href="https://labs.quansight.org/authors/hameer-abbasi.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Wed, 03 Jul 2019 17:43:50 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>uarray update: API changes, overhead and comparison to __array_function__</title><link>https://labs.quansight.org/blog/2019/07/uarray-update-api-changes-overhead-and-comparison-to-__array_function__/</link><dc:creator>Hameer Abbasi</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;code&gt;uarray&lt;/code&gt; is a generic override framework for objects and methods in Python. Since &lt;a href="https://labs.quansight.org/blog/2019/04/uarray-intro/"&gt;my last &lt;code&gt;uarray&lt;/code&gt; blogpost&lt;/a&gt;, there have been plenty of developments, changes to the API and improvements to the overhead of the protocol. Let’s begin with a walk-through of the current feature set and API, and then move on to current developments and how it compares to &lt;a href="https://labs.quansight.org/blog/2019/07/uarray-update-api-changes-overhead-and-comparison-to-__array_function__/www.numpy.org/neps/nep-0018-array-function-protocol.html"&gt;&lt;code&gt;__array_function__&lt;/code&gt;&lt;/a&gt;. For further details on the API and latest developments, please see &lt;a href="https://uarray.readthedocs.io/en/latest/generated/uarray.html"&gt;the API page for &lt;code&gt;uarray&lt;/code&gt;&lt;/a&gt;. The examples there are doctested, so they will always be current.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [1]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Enable __array_function__ for NumPy &amp;lt; 1.17.0&lt;/span&gt;
&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [2]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;uarray&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ua&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;In &lt;code&gt;uarray&lt;/code&gt;, the fundamental building block is a multimethod. Multimethods have a number of nice properties, such as automatic dispatch based on backends. It is important to note here that multimethods will be written by API authors, rather than implementors. Here's how we define a multimethod in &lt;code&gt;uarray&lt;/code&gt;:
&lt;/p&gt;&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2019/07/uarray-update-api-changes-overhead-and-comparison-to-__array_function__/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><guid>https://labs.quansight.org/blog/2019/07/uarray-update-api-changes-overhead-and-comparison-to-__array_function__/</guid><pubDate>Wed, 03 Jul 2019 11:36:54 GMT</pubDate></item><item><title>uarray: A Generic Override Framework for Methods</title><link>https://labs.quansight.org/blog/2019/04/uarray-intro/</link><dc:creator>Hameer Abbasi</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="uarray:-A-Generic-Override-Framework-for-Methods"&gt;&lt;code&gt;uarray&lt;/code&gt;: A Generic Override Framework for Methods&lt;a class="anchor-link" href="https://labs.quansight.org/blog/2019/04/uarray-intro/#uarray:-A-Generic-Override-Framework-for-Methods"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;uarray&lt;/code&gt; is an override framework for methods in Python. In the scientific Python ecosystem, and in other similar places, there has been one recurring problem: That similar tools to do a job have existed, but don't conform to a single, well-defined API. &lt;code&gt;uarray&lt;/code&gt; tries to solve this problem in general, but also for the scientific Python ecosystem in particular, by defining APIs independent of their implementations.&lt;/p&gt;
&lt;h3 id="Array-Libraries-in-the-Scientific-Python-Ecosystem"&gt;Array Libraries in the Scientific Python Ecosystem&lt;a class="anchor-link" href="https://labs.quansight.org/blog/2019/04/uarray-intro/#Array-Libraries-in-the-Scientific-Python-Ecosystem"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;When SciPy was created, and Numeric and Numarray unified into NumPy, it jump-started Python's data science community. The ecosystem grew quickly: Academics started moving to SciPy, and the Scikits that popped up made the transition all the more smooth.&lt;/p&gt;
&lt;p&gt;However, the scientific Python community also shifted during that time: GPUs and distributed computing emerged. Also, there were old ideas that couldn't really be used with NumPy's API, such as sparse arrays. To solve these problems, various libraries emerged:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dask, for distributed NumPy&lt;/li&gt;
&lt;li&gt;CuPy, for NumPy on Nvidia-branded GPUs.&lt;/li&gt;
&lt;li&gt;PyData/Sparse, a project started to make sparse arrays conform to the NumPy API&lt;/li&gt;
&lt;li&gt;Xnd, which extends the type system and the universal function concept found in NumPy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2019/04/uarray-intro/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><guid>https://labs.quansight.org/blog/2019/04/uarray-intro/</guid><pubDate>Tue, 30 Apr 2019 05:04:40 GMT</pubDate></item></channel></rss>